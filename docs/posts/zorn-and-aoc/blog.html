<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Himadri Mandal">
<meta name="dcterms.date" content="2023-11-16">

<title>Axiom of Choice, the Zorn’s Lemma, and the Foundations of Mathematics: Set Theory Part I – Cold Reflections</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../coldreflection.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-bd89562929948232a0cfc2a2280e30cc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../coldreflection.jpeg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Cold Reflections</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../thoughts"> 
<span class="menu-text">Thoughts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quirtt"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Axiom of Choice, the Zorn’s Lemma, and the Foundations of Mathematics: Set Theory Part I</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">set theory</div>
                <div class="quarto-category">math</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Himadri Mandal </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 16, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#russells-paradox" id="toc-russells-paradox" class="nav-link active" data-scroll-target="#russells-paradox"><strong><em>Russell’s Paradox</em></strong></a></li>
  <li><a href="#axiom-of-choice" id="toc-axiom-of-choice" class="nav-link" data-scroll-target="#axiom-of-choice"><strong><em>Axiom of Choice</em></strong></a></li>
  <li><a href="#zorns-lemma" id="toc-zorns-lemma" class="nav-link" data-scroll-target="#zorns-lemma"><strong><em>Zorn’s Lemma</em></strong></a></li>
  <li><a href="#zorn-and-axiom-of-choice-are-the-same" id="toc-zorn-and-axiom-of-choice-are-the-same" class="nav-link" data-scroll-target="#zorn-and-axiom-of-choice-are-the-same"><strong><em>Zorn and Axiom of Choice are the SAME!</em></strong></a></li>
  <li><a href="#footnotes" id="toc-footnotes" class="nav-link" data-scroll-target="#footnotes"><strong><em>Footnotes</em></strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Mathematics has long been built on the sturdy foundation of intuition. From counting pebbles to solving complex equations, mathematicians have relied on their inner compass to navigate the abstract landscapes of numbers and shapes. But as the 19th century dawned, something intriguing and unsettling began to occur – mathematics, the bedrock of human knowledge, was on the brink of a seismic shift.</p>
<p>This piece goes into <em>how</em> this happened, what changed - and its consequences. Though I might not know a lot of mathematics, I firmly believe that this is one of the most interesting (while being accessible) parts of mathematics.</p>
<p>All of this begins with arguably the most famous paradox in mathematics, logic, and the like - the Russell’s paradox.</p>
<section id="russells-paradox" class="level2">
<h2 class="anchored" data-anchor-id="russells-paradox"><strong><em>Russell’s Paradox</em></strong></h2>
<p>Let <span class="math inline">\(A\)</span> be the set of all sets that do not contain themselves. Does <span class="math inline">\(A\)</span> contain itself?</p>
<p><span class="math display">\[
A = \{x : x \not\in x\} \text{. Is } A \in A?
\]</span></p>
<hr>
<p>Well, if <span class="math inline">\(A \in A\)</span> then by the definition of <span class="math inline">\(A\)</span>, we get <span class="math inline">\(A \not \in A\)</span>. But if <span class="math inline">\(A \not\in A\)</span> then <span class="math inline">\(A \in A\)</span>. Poof.</p>
<p>This called for a need for formalism - intuition was just <em>not</em> enough. Here came Axiomatic Set Theory - one of the most famous systems of Axiomatic Set Theory is the <a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory"><strong>Zermelo Fraenkel set theory</strong></a><strong>.</strong> (Do click the link and read the axioms - they are fun! And everything makes sense at the end.)</p>
<p>Well, how does the <strong>Russell’s paradox</strong> get resolved? One of the axioms deals with this head-on.</p>
<section id="axiom-schema-of-specification-axiom-of-restricted-comprehension" class="level4">
<h4 class="anchored" data-anchor-id="axiom-schema-of-specification-axiom-of-restricted-comprehension"><em>Axiom Schema of Specification / Axiom of Restricted Comprehension</em></h4>
<p>Given a <em>parent set</em> <span class="math inline">\(z\)</span> we can construct a subset <span class="math inline">\(S \subseteq z\)</span> such that</p>
<p><span class="math display">\[
S = \{x \in z : \varphi(x)\}
\]</span></p>
<hr>
<p>Although this defines how we can create <em>subsets</em> from a parent set, it DOESN’T talk about creating sets of elements that follow a formula. Infact, we will need a sort of <span class="math inline">\(\text{``set of all sets: X"}\)</span> to talk about creating sets out of thin air.</p>
<p>However this is NOT a set (In <span class="math inline">\(\text{ZF}\)</span>) . How do we prove this? Well, if <span class="math inline">\(X\)</span> is the set of all sets, then <span class="math inline">\(P(X) \in X\)</span> which means there exists an injective function from <span class="math inline">\(f:P(X)\to X\)</span>. But we know by <a href="#thm-cantor" class="quarto-xref">Theorem&nbsp;3</a> that <span class="math inline">\(P(X) &gt;_{c} X\)</span>. This is a <a href="https://en.wikipedia.org/wiki/Class_(set_theory)"><strong><em>Class</em></strong></a>.</p>
</section>
</section>
<section id="axiom-of-choice" class="level2">
<h2 class="anchored" data-anchor-id="axiom-of-choice"><strong><em>Axiom of Choice</em></strong></h2>
<p>Let <span class="math inline">\(I\)</span> be an index set with a family of sets indexed on this index set <span class="math inline">\(\{A_i\}_{i \in I}\)</span>. Then there exists a choice function <span class="math inline">\(f:I \to A = \cup_{i \in I} A_i\)</span> such that <span class="math inline">\(f(i) \in A_i \ \forall i \in I\)</span>.</p>
<hr>
<p>This makes “intuitive” sense and is something that “should” be true. However, this is an independent statement in <span class="math inline">\(\text{ZF}\)</span>, which is to say - we CANNOT prove this by ONLY using the axioms of <span class="math inline">\(\text{ZF}\)</span>. There is an equivalent formulation of this axiom (which is used more often)</p>
</section>
<section id="zorns-lemma" class="level2">
<h2 class="anchored" data-anchor-id="zorns-lemma"><strong><em>Zorn’s Lemma</em></strong></h2>
<p>If <span class="math inline">\(P\)</span> is a nonempty partially ordered set such that every chain has an upper bound in <span class="math inline">\(P\)</span> then <span class="math inline">\(P\)</span> has a maximal element.</p>
<hr>
<p>There are quite a few words that need to be unpacked.</p>
<section id="definitions" class="level4">
<h4 class="anchored" data-anchor-id="definitions"><em>Definitions</em></h4>
<ol type="1">
<li><p>A binary relation <span class="math inline">\(R\)</span> on a set <span class="math inline">\(P\)</span> is a subset <span class="math inline">\(R\)</span> of <span class="math inline">\(P \times P\)</span>, <span class="math inline">\((x,y) \in R\)</span> and is often expressed as <span class="math inline">\(xRy\)</span>.</p></li>
<li><p>A binary relation <span class="math inline">\(R\)</span> is a partial order if</p>
<ol type="a">
<li><p>Reflexivity: <span class="math inline">\(xRx\)</span>, Transitivity: <span class="math inline">\(xRy, yRz \implies xRz\)</span>.</p></li>
<li><p>Antisymmetry: <span class="math inline">\(xRy, yRx \implies xRx\)</span>.</p></li>
</ol></li>
<li><p>A partial order is called a linear order if any two elements are comparable.</p></li>
<li><p>Let <span class="math inline">\((P, \leq)\)</span> be a poset (partially ordered set), a subset <span class="math inline">\(C \subseteq P\)</span> is called a <em>chain</em> if <span class="math inline">\(C\)</span> has a linear order.</p></li>
<li><p>Let <span class="math inline">\(A \subseteq P\)</span>, an upper bound for <span class="math inline">\(A\)</span> is an element <span class="math inline">\(x \in P\)</span> such that <span class="math inline">\(y \leq x, \ \forall y \in A\)</span>.</p></li>
<li><p>An <span class="math inline">\(x \in P\)</span> is called a maximal element if <span class="math inline">\(\not\exists \ y\neq x : x \leq y\)</span>.</p></li>
<li><p>A linearly ordered set is called <em>well ordered</em>&nbsp;if every nonempty subset has a first element.</p></li>
</ol>
</section>
</section>
<section id="zorn-and-axiom-of-choice-are-the-same" class="level2">
<h2 class="anchored" data-anchor-id="zorn-and-axiom-of-choice-are-the-same"><strong><em>Zorn and Axiom of Choice are the SAME!</em></strong></h2>
<p>We now conclude by proving that <span class="math inline">\(\text{Zorn}\iff\text{AoC}\)</span>.</p>
<div id="thm-zorntoaoc" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (<span class="math inline">\(\text{Zorn} \implies \text{AoC}\)</span>)</strong></span> <span class="math display">\[
\text{Zorn's Lemma} \ \implies \text{Axiom of Choice}
\]</span></p>
<hr>
<p>(This proof was communicated to me by PSC. Sir at ISIK)</p>
<p>Consider the following poset</p>
<p><span class="math display">\[
P = \{(J, f) : J \subseteq I, f : J \to A\text{ such that }f(j) \in A_j, \forall j \in J\}
\]</span></p>
<p>with the partial order:</p>
<p><span class="math display">\[
(J_1, f_1) \preceq (J_2, f_2) \text{ if } J_1 \subseteq J_2 \text{ and } f_2\Bigg|_{J_1} = f_1 \text{ ie. } f_2(x) = f_1(x), \forall x \in J_1
\]</span></p>
<p>then any chain <span class="math inline">\(C = \{(J_\alpha, f_\alpha) : \alpha \in Y\}\)</span>, has the trivial upperbound <span class="math inline">\((\cup J_\alpha, f) : f\Bigg |_{\alpha} = f_\alpha, \forall \alpha \in Y\)</span>. By Zorn’s Lemma, there exists a maximal element <span class="math inline">\(f:J \to A\)</span>, if <span class="math inline">\(J = I\)</span> , we are done. Otherwise, pick <span class="math inline">\(j \in I \setminus J\)</span> since <span class="math inline">\(A_j\)</span> is nonempty, pick <span class="math inline">\(x \in A_j\)</span> and consider <span class="math inline">\(f^{*}:J \cup \{j\} \to A\)</span> such that <span class="math inline">\(f(j) = x, f^{*}\Bigg|_{J} = f\)</span>, which contradicts maximality of <span class="math inline">\(f\)</span>. &nbsp;<span class="math inline">\(\blacksquare\)</span></p>
</div>
<div id="thm-aoctozorn" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 (<span class="math inline">\(\text{AoC} \implies \text{Zorn}\)</span>)</strong></span> <span class="math display">\[
\text{Axiom of Choice} \implies \text{Zorn's Lemma}
\]</span></p>
<p>This is <strong>definitely trickier</strong> to prove compared to the previous implication. I use transfinite induction and ordinals here (but if you don’t know about them I will probably make a post on them. Till then, check out <a href="https://venhance.github.io/napkin/Napkin.pdf">Napkin pg. 801</a>.)</p>
<p>Let <span class="math inline">\((P, \leq)\)</span> be the poset, where every chain has an upperbound. Assume there is <strong>no maximal element</strong>. Let <span class="math inline">\(x_0\)</span> be any element in <span class="math inline">\(P\)</span>. By assumption <span class="math inline">\(\exists x_1\)</span> s.t. <span class="math inline">\(x_0 \leq x_1\)</span>. But again, by assumption, <span class="math inline">\(\exists x_2\)</span> s.t. <span class="math inline">\(x_0 \leq x_1 \leq x_2\)</span>. Intuitively we create a chain <span class="math inline">\(x_0 \leq x_1 \leq x_2 \ \cdots\)</span> which has an upper bound <span class="math inline">\(x_\omega\)</span>, but since this isn’t the maximal element again - I get <span class="math inline">\(x_0 \leq x_1 \leq x_2 \leq \cdots \leq x_\omega \leq x_{\omega+1} \leq \cdots\)</span>. We must “eventually” run out.</p>
<p>Now to formalize this: for any element <span class="math inline">\(x \in P\)</span> consider the set <span class="math inline">\(S_x = \{y \in P : x \lneq y\}\)</span>. Clearly all <span class="math inline">\(S_x\)</span> are nonempty, because otherwise there is a maximal element. By AoC, there exists a choice function <span class="math inline">\(f:P \to \cup_{x \in P} S_x\)</span>, such that <span class="math inline">\(f(x) \in S_x \ \forall x \in P\)</span>. Using transfinite induction:</p>
<ul>
<li><p><u><strong>Step 1:</strong></u> <span class="math inline">\(x_0 \in P\)</span></p>
<p>Take <span class="math inline">\(x_1 = f(x_0)\)</span>. Then <span class="math inline">\(x_0 \leq x_1\)</span>. Similarly, obtain <span class="math inline">\(C_{i &lt; \omega} = x_0 \leq x_1 \leq \cdots\)</span>.</p></li>
<li><p><u><strong>Step 2:</strong></u> Let <span class="math inline">\(\lambda\)</span> be a limit ordinal. Defining <span class="math inline">\(x_\lambda = u(C_{i &lt; \lambda})\)</span> can be used to extend the chain.</p>
<p>Consider the upper bound of this chain <span class="math inline">\(x = u(C_{i &lt; \lambda})\)</span>. Clearly, <span class="math inline">\(x\)</span> cannot be in <span class="math inline">\(C\)</span>, because otherwise, <span class="math inline">\(\exists k\)</span> s.t. <span class="math inline">\(C \ni x_k \geq x = x_{k-1}\)</span> which forces <span class="math inline">\(x = x_k = f(x)\)</span> which is not possible by the definition of <span class="math inline">\(f\)</span>. So, define <span class="math inline">\(x_{\lambda} = x\)</span>.</p></li>
</ul>
<p>Then - keep doing this. So, you end up with a chain <span class="math inline">\(C = x_0 \leq x_1 \leq \cdots \leq x_\omega \leq x_{\omega + 1} \leq \cdots \leq x_{\omega + \omega} \leq \cdots\)</span>.</p>
<p>To finish we need magic: Hartogs’s theorem.</p>
<section id="hartogss-theorem" class="level3">
<h3 class="anchored" data-anchor-id="hartogss-theorem">Hartogs’s Theorem</h3>
<p>Given any set <span class="math inline">\(X\)</span>, there exists an ordinal <span class="math inline">\(\alpha\)</span> such that there is no injection <span class="math inline">\(f:\alpha \to X\)</span>.</p>
<hr>
<p>Consider the class of ordinals <span class="math inline">\(\alpha = \{\beta \in \text{Ord} \ | \ \exists f:\beta \hookrightarrow X\}\)</span>. Using the power set axiom twice - we get that <span class="math inline">\(\mathcal{P}(X \times X)\)</span> is a set. Consider the class <span class="math inline">\(W\)</span> of all reflexive well orderings of subsets of <span class="math inline">\(X\)</span>, since this is a definable subclass of <span class="math inline">\(\mathcal{P}(X \times X)\)</span>, it is a set by Schema of Specification.</p>
<p>The class of all <a href="https://en.wikipedia.org/wiki/Order_type">order types</a> of well-orderings in <span class="math inline">\(W\)</span> is a set by the axiom schema of replacement: <span class="math inline">\((\operatorname{Domain}(w), w) \cong (\beta, \leq)\)</span> where <span class="math inline">\(w\)</span> is a well-ordering on <span class="math inline">\(\operatorname{Domain}(w)\)</span> which gets mapped to the order type <span class="math inline">\((\beta, \leq)\)</span>.</p>
<p>Now we can see that <span class="math inline">\(W\)</span>, a set, is precisely <span class="math inline">\(\alpha\)</span>. Since every well-ordering of a subset of <span class="math inline">\(X\)</span> defines an injective function from <span class="math inline">\(\beta \hookrightarrow X\)</span> where <span class="math inline">\(\beta\)</span> is some ordinal. And the other side is true as well. To finish: <span class="math inline">\(\alpha\)</span> is a <em>transitive</em> set of ordinals, which means it is an ordinal itself. Ofcourse, then, <span class="math inline">\(\alpha\)</span> is the first ordinal with no injection <span class="math inline">\(\blacksquare\)</span>.</p>
<hr>
<p>So, the chain <em>has</em> to eventually end. We are done.</p>
</section>
</div>
</section>
<section id="footnotes" class="level2">
<h2 class="anchored" data-anchor-id="footnotes"><strong><em>Footnotes</em></strong></h2>
<div id="thm-cantor" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Cantor’s Diagonal Argument)</strong></span> <span class="math display">\[X &lt;_{c} P(X) \ \forall \ X\]</span></p>
<hr>
<p>Assume for the sake of contradiction <span class="math inline">\(P(X) =_{c} X\)</span> (where <span class="math inline">\(=_{c}\)</span> means that there exists a bijection between the sets). Thus, there is a surjection <span class="math inline">\(f:X \to P(X)\)</span>. Consider</p>
<p><span class="math display">\[
A = \{x \in X: x \not\in f(x)\}
\]</span></p>
<p>But since <span class="math inline">\(f\)</span> is a surjection, <span class="math inline">\(\exists x_0 \ f(x_0) = A\)</span> then</p>
<p><span class="math display">\[
x_0 \in A \iff x_0 \not\in A.
\]</span></p>
<p>a contradiction. (This is pretty much the same idea as the famous proof of real numbers being uncountable.)</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>